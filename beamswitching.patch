 drivers/net/wireless/ath/ath9k/Makefile |    2 
 drivers/net/wireless/ath/ath9k/ath9k.h  |   11 +
 drivers/net/wireless/ath/ath9k/beacon.c |   34 ++++
 drivers/net/wireless/ath/ath9k/init.c   |   14 +
 drivers/net/wireless/ath/ath9k/main.c   |   22 +++
 drivers/net/wireless/ath/ath9k/xmit.c   |   33 +++-
 include/linux/ieee80211.h               |   11 +
 include/net/cfg80211.h                  |   18 ++
 include/net/mac80211.h                  |   33 ++++
 include/uapi/linux/nl80211.h            |   23 +++
 net/mac80211/Makefile                   |    2 
 net/mac80211/cfg.c                      |   26 +++
 net/mac80211/ibss.c                     |  193 ++++++++++++++++++++++++++
 net/mac80211/ieee80211_i.h              |   11 +
 net/mac80211/mlme.c                     |   95 +++++++++++++
 net/mac80211/rx.c                       |    9 +
 net/mac80211/sta_info.c                 |   20 ++
 net/mac80211/sta_info.h                 |   15 ++
 net/mac80211/tx.c                       |  232 ++++++++++++++++++++++++++++++++
 net/mac80211/util.c                     |   17 ++
 net/wireless/Makefile                   |    3 
 net/wireless/nl80211.c                  |   60 ++++++++
 net/wireless/rdev-ops.h                 |   14 +
 net/wireless/trace.h                    |   43 +++++
 spa/spa.h                               |   82 +++++++++++
 25 files changed, 1009 insertions(+), 14 deletions(-)
diff -Npurd /home/user/download/compat-wireless-2014-05-22/drivers/net/wireless/ath/ath9k/ath9k.h /home/user/modified/compat-wireless-2014-05-22/drivers/net/wireless/ath/ath9k/ath9k.h
--- /home/user/download/compat-wireless-2014-05-22/drivers/net/wireless/ath/ath9k/ath9k.h	2014-11-30 08:56:34.435284759 +0200
+++ /home/user/modified/compat-wireless-2014-05-22/drivers/net/wireless/ath/ath9k/ath9k.h	2014-12-22 13:26:45.093835344 +0200
@@ -1,6 +1,8 @@
 /*
  * Copyright (c) 2008-2011 Atheros Communications Inc.
  *
+ * Modified by Mofolo Mofolo <mmofolo@csir.co.za>, December 2014
+ *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
  * copyright notice and this permission notice appear in all copies.
@@ -29,6 +31,10 @@
 #include "dfs.h"
 #include "spectral.h"
 
+#ifdef FCI_SPA
+#define MAX_BEAM_NUMBER 5
+#endif // FCI_SPA
+
 struct ath_node;
 
 extern struct ieee80211_ops ath9k_ops;
@@ -796,6 +802,11 @@ struct ath_softc {
 	atomic_t wow_sleep_proc_intr; /* in the middle of WoW sleep ? */
 	u32 wow_intr_before_sleep;
 #endif
+
+#ifdef FCI_SPA
+       u8 sc_spa_beam;
+       u8 sc_beacon_beam_id;
+#endif // FCI_SPA
 };
 
 /********/
diff -Npurd /home/user/download/compat-wireless-2014-05-22/drivers/net/wireless/ath/ath9k/beacon.c /home/user/modified/compat-wireless-2014-05-22/drivers/net/wireless/ath/ath9k/beacon.c
--- /home/user/download/compat-wireless-2014-05-22/drivers/net/wireless/ath/ath9k/beacon.c	2014-05-23 19:32:17.000000000 +0200
+++ /home/user/modified/compat-wireless-2014-05-22/drivers/net/wireless/ath/ath9k/beacon.c	2015-02-24 17:17:00.063587056 +0200
@@ -1,6 +1,8 @@
 /*
  * Copyright (c) 2008-2011 Atheros Communications Inc.
  *
+ * Modified by Mofolo Mofolo <mmofolo@csir.co.za>, December 2014
+ *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
  * copyright notice and this permission notice appear in all copies.
@@ -16,6 +18,9 @@
 
 #include <linux/dma-mapping.h>
 #include "ath9k.h"
+#ifdef FCI_SPA
+       #include "../spa/spa.h"
+#endif /* FCI_SPA */
 
 #define FUDGE 2
 
@@ -134,7 +139,21 @@ static struct ath_buf *ath9k_beacon_gene
 		bf->bf_mpdu = NULL;
 	}
 
+#ifdef FCI_SPA
+      sc->sc_beacon_beam_id++;
+      /*printk(KERN_INFO "%s: Incresing beam_ID for sending a beacon to \"%d\"\n",
+	                __func__, sc->sc_beacon_beam_id);*/           
+      if (sc->sc_beacon_beam_id < MAX_BEAM_NUMBER) {
+            skb = spa_beacon_get(hw, vif,sc->sc_beacon_beam_id);
+      }
+      else {
+            skb = spa_beacon_get(hw, vif, 0);
+            sc->sc_beacon_beam_id = 0;                
+      }
+#else      
 	skb = ieee80211_beacon_get(hw, vif);
+#endif /* FCI_SPA*/
+	
 	if (skb == NULL)
 		return NULL;
 
@@ -420,11 +439,26 @@ void ath9k_beacon_tasklet(unsigned long
 		ath_dbg(common, BEACON,
 			"Transmitting beacon for slot: %d\n", slot);
 
+#ifdef FCI_SPA
+           /* printk(KERN_INFO "%s: Activating beam_ID \"%d\" to send a beacon\n",
+	                __func__, sc->sc_beacon_beam_id);*/
+            spa_gpio(sc->sc_beacon_beam_id);
+
 		/* NB: cabq traffic should already be queued and primed */
 		ath9k_hw_puttxbuf(ah, sc->beacon.beaconq, bf->bf_daddr);
 
 		if (!edma)
 			ath9k_hw_txstart(ah, sc->beacon.beaconq);
+            
+            spa_gpio(0);
+#else
+		/* NB: cabq traffic should already be queued and primed */
+		ath9k_hw_puttxbuf(ah, sc->beacon.beaconq, bf->bf_daddr);
+
+		if (!edma)
+			ath9k_hw_txstart(ah, sc->beacon.beaconq);
+     
+#endif /* FCI_SPA*/			
 	}
 }
 
diff -Npurd /home/user/download/compat-wireless-2014-05-22/drivers/net/wireless/ath/ath9k/init.c /home/user/modified/compat-wireless-2014-05-22/drivers/net/wireless/ath/ath9k/init.c
--- /home/user/download/compat-wireless-2014-05-22/drivers/net/wireless/ath/ath9k/init.c	2014-11-30 08:56:34.475284760 +0200
+++ /home/user/modified/compat-wireless-2014-05-22/drivers/net/wireless/ath/ath9k/init.c	2015-02-24 16:58:39.787558883 +0200
@@ -1,6 +1,8 @@
 /*
  * Copyright (c) 2008-2011 Atheros Communications Inc.
  *
+ * Modified by Mofolo Mofolo <mmofolo@csir.co.za>, December 2014
+ *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
  * copyright notice and this permission notice appear in all copies.
@@ -25,6 +27,12 @@
 
 #include "ath9k.h"
 
+#ifdef FCI_SPA
+        #include <asm/mach-ath79/ar71xx_regs.h>
+        #include <asm/mach-ath79/ath79.h>
+        #include "../spa/spa.h"
+#endif /* FCI_SPA */
+
 struct ath9k_eeprom_ctx {
 	struct completion complete;
 	struct ath_hw *ah;
@@ -861,6 +869,12 @@ int ath9k_init_device(u16 devid, struct
 	ath_init_leds(sc);
 	ath_start_rfkill_poll(sc);
 
+#ifdef FCI_SPA
+      printk(KERN_INFO "%s: SPA module initialized in this function\n",__func__);
+	spa_setup_io();
+	sc->sc_beacon_beam_id = 0;
+#endif /* FCI_SPA */
+
 	return 0;
 
 debug_cleanup:
diff -Npurd /home/user/download/compat-wireless-2014-05-22/drivers/net/wireless/ath/ath9k/main.c /home/user/modified/compat-wireless-2014-05-22/drivers/net/wireless/ath/ath9k/main.c
--- /home/user/download/compat-wireless-2014-05-22/drivers/net/wireless/ath/ath9k/main.c	2014-11-30 08:56:34.491284760 +0200
+++ /home/user/modified/compat-wireless-2014-05-22/drivers/net/wireless/ath/ath9k/main.c	2015-02-24 15:17:38.691403689 +0200
@@ -1,6 +1,8 @@
 /*
  * Copyright (c) 2008-2011 Atheros Communications Inc.
  *
+ * Modified by Mofolo Mofolo <mmofolo@csir.co.za>, December 2014
+ *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
  * copyright notice and this permission notice appear in all copies.
@@ -19,6 +21,12 @@
 #include "ath9k.h"
 #include "btcoex.h"
 
+#ifdef FCI_SPA
+        #include <linux/gpio.h>
+        #include <asm/mach-ath79/ath79.h>
+        #include "../spa/spa.h"
+#endif /* FCI_SPA */
+
 static void ath9k_set_assoc_state(struct ath_softc *sc,
 				  struct ieee80211_vif *vif);
 
@@ -881,6 +889,16 @@ static void ath9k_tx(struct ieee80211_hw
 		TX_STAT_INC(txctl.txq->axq_qnum, txfailed);
 		goto exit;
 	}
+	
+#ifdef FCI_SPA
+        if (control->sta)
+        {
+              /*printk(KERN_INFO " %pM using beam \"%d\" to communicate with %pM\n",
+	        common->macaddr, control->sta->is_spa_beam, control->sta->addr);*/
+	        sc->sc_spa_beam = control->sta->is_spa_beam;
+	        spa_gpio(control->sta->is_spa_beam);
+	 }
+#endif /* FCI_SPA */
 
 	return;
 exit:
@@ -1506,6 +1524,10 @@ static int ath9k_sta_remove(struct ieee8
 
 	ath9k_del_ps_key(sc, vif, sta);
 	ath_node_detach(sc, sta);
+	
+#ifdef FCI_SPA
+	printk(KERN_INFO "%s: A neighbor station %pM was removed from the station list\n", __func__, sta->addr);
+#endif // FCI_SPA
 
 	return 0;
 }
diff -Npurd /home/user/download/compat-wireless-2014-05-22/drivers/net/wireless/ath/ath9k/Makefile /home/user/modified/compat-wireless-2014-05-22/drivers/net/wireless/ath/ath9k/Makefile
--- /home/user/download/compat-wireless-2014-05-22/drivers/net/wireless/ath/ath9k/Makefile	2014-11-30 08:56:34.475284760 +0200
+++ /home/user/modified/compat-wireless-2014-05-22/drivers/net/wireless/ath/ath9k/Makefile	2014-12-22 13:13:08.745814441 +0200
@@ -1,3 +1,5 @@
+ccflags-y += -DFCI_SPA
+
 ath9k-y +=	beacon.o \
 		gpio.o \
 		init.o \
diff -Npurd /home/user/download/compat-wireless-2014-05-22/drivers/net/wireless/ath/ath9k/xmit.c /home/user/modified/compat-wireless-2014-05-22/drivers/net/wireless/ath/ath9k/xmit.c
--- /home/user/download/compat-wireless-2014-05-22/drivers/net/wireless/ath/ath9k/xmit.c	2014-11-30 08:56:33.991284748 +0200
+++ /home/user/modified/compat-wireless-2014-05-22/drivers/net/wireless/ath/ath9k/xmit.c	2015-03-19 09:35:30.574808370 +0200
@@ -1,6 +1,8 @@
 /*
  * Copyright (c) 2008-2011 Atheros Communications Inc.
  *
+ * Modified by Mofolo Mofolo <mmofolo@csir.co.za>, December 2014
+ *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
  * copyright notice and this permission notice appear in all copies.
@@ -17,6 +19,13 @@
 #include <linux/dma-mapping.h>
 #include "ath9k.h"
 #include "ar9003_mac.h"
+#include "../net/mac80211/ieee80211_i.h"
+
+#ifdef FCI_SPA
+        #include <linux/gpio.h>
+        #include <asm/mach-ath79/ath79.h>
+        #include "../spa/spa.h"
+#endif // FCI_SPA
 
 #define BITS_PER_BYTE           8
 #define OFDM_PLCP_BITS          22
@@ -1950,7 +1959,7 @@ static void ath_tx_txqaddbuf(struct ath_
 			bf = bf_last->bf_next;
 			bf_last->bf_next = NULL;
 		}
-	}
+	}	
 }
 
 static void ath_tx_send_normal(struct ath_softc *sc, struct ath_txq *txq,
@@ -1960,7 +1969,7 @@ static void ath_tx_send_normal(struct at
 	struct ath_frame_info *fi = get_frame_info(skb);
 	struct list_head bf_head;
 	struct ath_buf *bf = fi->bf;
-
+	
 	INIT_LIST_HEAD(&bf_head);
 	list_add_tail(&bf->list, &bf_head);
 	bf->bf_state.bf_type = 0;
@@ -1972,6 +1981,13 @@ static void ath_tx_send_normal(struct at
 	bf->bf_next = NULL;
 	bf->bf_lastbf = bf;
 	ath_tx_fill_desc(sc, bf, txq, fi->framelen);
+#ifdef FCI_SPA
+      if (sc->sc_spa_beam != 0 ) {
+            printk(KERN_INFO "%s: Using beam \"%d\" to communicate...........\n",
+                        __func__, sc->sc_spa_beam);
+            spa_gpio(sc->sc_spa_beam);    
+       }
+#endif /* FCI_SPA */                         	
 	ath_tx_txqaddbuf(sc, txq, &bf_head, false);
 	TX_STAT_INC(txq->axq_qnum, queued);
 }
@@ -2232,7 +2248,6 @@ int ath_tx_start(struct ieee80211_hw *hw
 
 	ath_set_rates(vif, sta, bf);
 	ath_tx_send_normal(sc, txq, tid, skb);
-
 out:
 	ath_txq_unlock(sc, txq);
 
@@ -2351,9 +2366,16 @@ static void ath_tx_complete(struct ath_s
 					PS_WAIT_FOR_TX_ACK));
 	}
 	spin_unlock_irqrestore(&sc->sc_pm_lock, flags);
-
+	
 	__skb_queue_tail(&txq->complete_q, skb);
 	ath_txq_skb_done(sc, txq, skb);
+
+#ifdef FCI_SPA
+      if (sc->sc_spa_beam) {
+            sc->sc_spa_beam=0; /*Reset SPA beam to default: omidirectional*/
+            spa_gpio(0);
+      }
+#endif // FCI_SPA
 }
 
 static void ath_tx_complete_buf(struct ath_softc *sc, struct ath_buf *bf,
@@ -2785,8 +2807,7 @@ int ath9k_tx99_send(struct ath_softc *sc
 
 	ath9k_hw_set_desc_link(sc->sc_ah, bf->bf_desc, bf->bf_daddr);
 	ath9k_hw_tx99_start(sc->sc_ah, txctl->txq->axq_qnum);
-
-	ath_tx_send_normal(sc, txctl->txq, NULL, skb);
+      ath_tx_send_normal(sc, txctl->txq, NULL, skb);
 
 	return 0;
 }
diff -Npurd /home/user/download/compat-wireless-2014-05-22/include/linux/ieee80211.h /home/user/modified/compat-wireless-2014-05-22/include/linux/ieee80211.h
--- /home/user/download/compat-wireless-2014-05-22/include/linux/ieee80211.h	2014-05-23 19:32:17.000000000 +0200
+++ /home/user/modified/compat-wireless-2014-05-22/include/linux/ieee80211.h	2014-12-22 15:58:24.270068328 +0200
@@ -7,6 +7,8 @@
  * Copyright (c) 2005, Devicescape Software, Inc.
  * Copyright (c) 2006, Michael Wu <flamingice@sourmilk.net>
  *
+ * Modified by Mofolo Mofolo <mmofolo@csir.co.za>, December 2014
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
@@ -973,6 +975,12 @@ struct ieee80211_mgmt {
 					u8 action_code;
 					u8 operating_mode;
 				} __packed vht_opmode_notif;
+#ifdef FCI_SPA				
+				struct {
+				        u8 action;
+				        u8 beam_id;
+				} __packed spa_beam_feedback;
+#endif /* FCI_SPA */
 			} u;
 		} __packed action;
 	} u;
@@ -1853,6 +1861,9 @@ enum ieee80211_category {
 	WLAN_CATEGORY_FST = 18,
 	WLAN_CATEGORY_UNPROT_DMG = 20,
 	WLAN_CATEGORY_VHT = 21,
+#ifdef FCI_SPA
+      WLAN_CATEGORY_SPA_BEAM_FEEDBACK = 125,	
+#endif /* FCI_SPA */      
 	WLAN_CATEGORY_VENDOR_SPECIFIC_PROTECTED = 126,
 	WLAN_CATEGORY_VENDOR_SPECIFIC = 127,
 };
diff -Npurd /home/user/download/compat-wireless-2014-05-22/include/net/cfg80211.h /home/user/modified/compat-wireless-2014-05-22/include/net/cfg80211.h
--- /home/user/download/compat-wireless-2014-05-22/include/net/cfg80211.h	2014-11-30 08:56:34.415284758 +0200
+++ /home/user/modified/compat-wireless-2014-05-22/include/net/cfg80211.h	2014-12-22 16:00:04.038070883 +0200
@@ -5,6 +5,8 @@
  *
  * Copyright 2006-2010	Johannes Berg <johannes@sipsolutions.net>
  *
+ * Modified by Mofolo Mofolo <mmofolo@csir.co.za>, December 2014
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
@@ -874,6 +876,9 @@ int cfg80211_check_station_change(struct
  * @STATION_INFO_CHAIN_SIGNAL: @chain_signal filled
  * @STATION_INFO_CHAIN_SIGNAL_AVG: @chain_signal_avg filled
  * @STATION_INFO_EXPECTED_THROUGHPUT: @expected_throughput filled
+ * #ifdef FCI_SPA
+ * @STATION_INFO_SPA_BEAM: @mapped corrosponding spa beam number filled
+ * #endif // FCI_SPA
  */
 enum station_info_flags {
 	STATION_INFO_INACTIVE_TIME		= BIT(0),
@@ -905,6 +910,9 @@ enum station_info_flags {
 	STATION_INFO_CHAIN_SIGNAL		= BIT(26),
 	STATION_INFO_CHAIN_SIGNAL_AVG		= BIT(27),
 	STATION_INFO_EXPECTED_THROUGHPUT	= BIT(28),
+#ifdef FCI_SPA
+        STATION_INFO_SPA_BEAM                   = BIT(29),
+#endif // FCI_SPA
 };
 
 /**
@@ -1072,6 +1080,9 @@ struct station_info {
 	 * Note: Add a new enum station_info_flags value for each new field and
 	 * use it to check which fields are initialized.
 	 */
+#ifdef FCI_SPA
+        u8 spa_beam;
+#endif // FCI_SPA
 };
 
 /**
@@ -2558,6 +2569,13 @@ struct cfg80211_ops {
 
 	int	(*set_ap_chanwidth)(struct wiphy *wiphy, struct net_device *dev,
 				    struct cfg80211_chan_def *chandef);
+#ifdef FCI_SPA
+        int     (*spabeam)(struct wiphy *wiphy, struct net_device *dev,
+                           u8 *neighbor_addr, u8 beam_number);
+        int     (*get_spabeam)(struct wiphy *wiphy, struct net_device *dev,
+                           u8 *neighbor_addr, u8 beam_number);                         
+
+#endif //FCI_SPA                          
 };
 
 /*
diff -Npurd /home/user/download/compat-wireless-2014-05-22/include/net/mac80211.h /home/user/modified/compat-wireless-2014-05-22/include/net/mac80211.h
--- /home/user/download/compat-wireless-2014-05-22/include/net/mac80211.h	2014-11-30 08:56:34.419284759 +0200
+++ /home/user/modified/compat-wireless-2014-05-22/include/net/mac80211.h	2014-12-22 15:48:46.414053532 +0200
@@ -5,6 +5,8 @@
  * Copyright 2006-2007	Jiri Benc <jbenc@suse.cz>
  * Copyright 2007-2010	Johannes Berg <johannes@sipsolutions.net>
  *
+ * Modified by Mofolo Mofolo <mmofolo@csir.co.za>, December 2014
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
@@ -989,6 +991,9 @@ enum ieee80211_conf_changed {
 	IEEE80211_CONF_CHANGE_CHANNEL		= BIT(6),
 	IEEE80211_CONF_CHANGE_RETRY_LIMITS	= BIT(7),
 	IEEE80211_CONF_CHANGE_IDLE		= BIT(8),
+#ifdef FCI_SPA
+        IEEE80211_CONF_CHANGE_SPA_BEAM		= BIT(9),
+#endif // FCI_SPA
 };
 
 /**
@@ -1394,6 +1399,10 @@ struct ieee80211_sta {
 	enum ieee80211_smps_mode smps_mode;
 	struct ieee80211_sta_rates __rcu *rates;
 	bool tdls;
+	
+#ifdef FCI_SPA
+        u8 is_spa_beam;
+#endif /* FCI_SPA */
 
 	/* must be last */
 	u8 drv_priv[0] __aligned(sizeof(void *));
@@ -2970,6 +2979,10 @@ struct ieee80211_ops {
 	int (*join_ibss)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
 	void (*leave_ibss)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
 	u32 (*get_expected_throughput)(struct ieee80211_sta *sta);
+	
+#ifdef FCI_SPA
+        int (*set_spabeam)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
+#endif // FCI_SPA
 };
 
 /**
@@ -3515,6 +3528,26 @@ static inline struct sk_buff *ieee80211_
  */
 u8 ieee80211_csa_update_counter(struct ieee80211_vif *vif);
 
+#ifdef FCI_SPA
+/** See ieee80211_beacon_get_tim() for most details. Additional parameter
+ * @beam_id: is the beam number to be used to transmit a beacon.
+ */ 
+struct sk_buff *spa_beacon_get_tim(struct ieee80211_hw *hw,
+					 struct ieee80211_vif *vif,
+					 u16 *tim_offset, u16 *tim_length,
+					 u8 beam_id);
+/**
+ * See ieee80211_beacon_get() for most details. Additional parameter 
+ * @beam_id: is the beam number to be used to transmit a beacon.
+ */
+static inline struct sk_buff *spa_beacon_get(struct ieee80211_hw *hw,
+						   struct ieee80211_vif *vif,
+						      u8 beam_id)
+{
+	return spa_beacon_get_tim(hw, vif, NULL, NULL, beam_id);
+}
+#endif /* FCI_SPA */
+
 /**
  * ieee80211_csa_finish - notify mac80211 about channel switch
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
diff -Npurd /home/user/download/compat-wireless-2014-05-22/include/uapi/linux/nl80211.h /home/user/modified/compat-wireless-2014-05-22/include/uapi/linux/nl80211.h
--- /home/user/download/compat-wireless-2014-05-22/include/uapi/linux/nl80211.h	2014-11-30 08:56:34.419284759 +0200
+++ /home/user/modified/compat-wireless-2014-05-22/include/uapi/linux/nl80211.h	2014-12-22 13:13:08.749814441 +0200
@@ -11,6 +11,8 @@
  * Copyright 2008 Jouni Malinen <jouni.malinen@atheros.com>
  * Copyright 2008 Colin McCabe <colin@cozybit.com>
  *
+ * Modified by Mofolo Mofolo <mmofolo@csir.co.za>, December 2014
+ *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
  * copyright notice and this permission notice appear in all copies.
@@ -722,6 +724,9 @@
  *	QoS mapping is relevant for IP packets, it is only valid during an
  *	association. This is cleared on disassociation and AP restart.
  *
+ * @NL80211_CMD_MAP_SPA_BEAM: Configuring the beam_ID to use when communicating 
+ *      with specified neigboring station.
+ *
  * @NL80211_CMD_MAX: highest used command number
  * @__NL80211_CMD_AFTER_LAST: internal use
  */
@@ -892,6 +897,10 @@ enum nl80211_commands {
 	NL80211_CMD_VENDOR,
 
 	NL80211_CMD_SET_QOS_MAP,
+	
+#ifdef FCI_SPA	
+	NL80211_CMD_MAP_SPA_BEAM,
+#endif // FCI_SPA
 
 	/* add new commands above here */
 
@@ -1593,6 +1602,9 @@ enum nl80211_commands {
  *
  * @NL80211_ATTR_WIPHY_ANTENNA_GAIN: Configured antenna gain. Used to reduce
  *	transmit power to stay within regulatory limits. u32, dBi.
+ * 
+ * @NL80211_ATTR_SPA_NEXT_HOP: MAC address of the next hop to map spa_beam
+ * @NL80211_ATTR_SPA_BEAM_NUMBER: SPA antenna beam_ID to be mapped. u8 
  *
  * @NL80211_ATTR_MAX: highest attribute number currently defined
  * @__NL80211_ATTR_AFTER_LAST: internal use
@@ -1936,6 +1948,11 @@ enum nl80211_attrs {
 
 	NL80211_ATTR_WIPHY_ANTENNA_GAIN,
 
+#ifdef FCI_SPA
+	NL80211_ATTR_SPA_BEAM_NUMBER,
+	NL80211_ATTR_SPA_NEXT_HOP,
+#endif // FCI_SPA
+
 	/* add attributes here, update the policy in nl80211.c */
 
 	__NL80211_ATTR_AFTER_LAST,
@@ -2206,6 +2223,9 @@ enum nl80211_sta_bss_param {
  *	Same format as NL80211_STA_INFO_CHAIN_SIGNAL.
  * @NL80211_STA_EXPECTED_THROUGHPUT: expected throughput considering also the
  *	802.11 header (u32, kbps)
+ *
+ * @NL80211_STA_INFO_BEAM: SPA antenna beam_ID that has been mapped. (u8)
+ *
  * @__NL80211_STA_INFO_AFTER_LAST: internal
  * @NL80211_STA_INFO_MAX: highest possible station info attribute
  */
@@ -2238,6 +2258,9 @@ enum nl80211_sta_info {
 	NL80211_STA_INFO_CHAIN_SIGNAL,
 	NL80211_STA_INFO_CHAIN_SIGNAL_AVG,
 	NL80211_STA_INFO_EXPECTED_THROUGHPUT,
+#ifdef FCI_SPA
+	NL80211_STA_INFO_BEAM,
+#endif /* FCI_SPA */
 
 	/* keep last */
 	__NL80211_STA_INFO_AFTER_LAST,
diff -Npurd /home/user/download/compat-wireless-2014-05-22/net/mac80211/cfg.c /home/user/modified/compat-wireless-2014-05-22/net/mac80211/cfg.c
--- /home/user/download/compat-wireless-2014-05-22/net/mac80211/cfg.c	2014-11-30 08:56:34.423284759 +0200
+++ /home/user/modified/compat-wireless-2014-05-22/net/mac80211/cfg.c	2014-12-22 13:13:08.749814441 +0200
@@ -3,6 +3,8 @@
  *
  * Copyright 2006-2010	Johannes Berg <johannes@sipsolutions.net>
  *
+ * Modified by Mofolo Mofolo <mmofolo@csir.co.za>, December 2014
+ *
  * This file is GPLv2 as found in COPYING.
  */
 
@@ -20,6 +22,26 @@
 #include "rate.h"
 #include "mesh.h"
 
+#ifdef FCI_SPA
+static int spa_beam_mapping(struct wiphy *wiphy, struct net_device *dev,
+                           u8 *neighbor_addr, u8 beam_number)
+{
+        struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+        struct sta_info *sta;
+        
+        rcu_read_lock();
+        sta = sta_info_get(sdata, neighbor_addr);
+        if (!sta) {
+            rcu_read_unlock();
+            printk(KERN_INFO "No station with this mac_address %pM in the list of associated stations.\n", neighbor_addr);
+            return -ENOENT;
+        }
+        sta->sta.is_spa_beam = beam_number;
+        rcu_read_unlock();
+        return 0;
+}               
+#endif /* FCI_SPA */
+           
 static struct wireless_dev *ieee80211_add_iface(struct wiphy *wiphy,
 						const char *name,
 						enum nl80211_iftype type,
@@ -3558,4 +3580,8 @@ const struct cfg80211_ops mac80211_confi
 	.channel_switch = ieee80211_channel_switch,
 	.set_qos_map = ieee80211_set_qos_map,
 	.set_ap_chanwidth = ieee80211_set_ap_chanwidth,
+	
+#ifdef FCI_SPA
+        .spabeam = spa_beam_mapping,
+#endif // FCI_SPA        	
 };
diff -Npurd /home/user/download/compat-wireless-2014-05-22/net/mac80211/ibss.c /home/user/modified/compat-wireless-2014-05-22/net/mac80211/ibss.c
--- /home/user/download/compat-wireless-2014-05-22/net/mac80211/ibss.c	2014-11-30 08:56:33.991284748 +0200
+++ /home/user/modified/compat-wireless-2014-05-22/net/mac80211/ibss.c	2015-03-24 09:59:09.381299199 +0200
@@ -7,6 +7,8 @@
  * Copyright 2007, Michael Wu <flamingice@sourmilk.net>
  * Copyright 2009, Johannes Berg <johannes@sipsolutions.net>
  *
+ * Modified by Mofolo Mofolo <mmofolo@csir.co.za>, December 2014
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
@@ -34,6 +36,29 @@
 
 #define IEEE80211_IBSS_MAX_STA_ENTRIES 128
 
+#ifdef FCI_SPA
+static void spa_initialize_beam_feedback_interval(struct ieee80211_local *local)
+{
+      u8 i;
+      unsigned long previous=1;
+      
+      for (i=0; i <= SPA_MAX_BEAMS; i++) {
+            previous = previous*4;
+            local->spa_beam_feedback_interval[i] = previous;
+      }      
+}
+
+static void spa_initialize_beam_signal_averages(struct sta_info *sta) 
+{
+      u8 i;
+    
+      for (i=0; i <= SPA_MAX_BEAMS; i++) {
+            ewma_init(&sta->spa_beam_beacon_signals[i], 1024, 8);
+      }  
+
+}
+#endif /* FCI_SPA */
+
 static struct beacon_data *
 ieee80211_ibss_build_presp(struct ieee80211_sub_if_data *sdata,
 			   const int beacon_int, const u32 basic_rates,
@@ -321,6 +346,10 @@ static void __ieee80211_sta_join_ibss(st
 	rcu_assign_pointer(ifibss->presp, presp);
 	mgmt = (void *)presp->head;
 
+#ifdef FCI_SPA
+      spa_initialize_beam_feedback_interval(sdata->local);
+#endif /*FCI_SPA*/  
+
 	sdata->vif.bss_conf.enable_beacon = true;
 	sdata->vif.bss_conf.beacon_int = beacon_int;
 	sdata->vif.bss_conf.basic_rates = basic_rates;
@@ -468,7 +497,7 @@ static void ieee80211_sta_join_ibss(stru
 				  &chandef,
 				  basic_rates,
 				  cbss->capability,
-				  tsf, false);
+				  tsf, false);    
 }
 
 int ieee80211_ibss_csa_beacon(struct ieee80211_sub_if_data *sdata,
@@ -598,6 +627,14 @@ static struct sta_info *ieee80211_ibss_f
 	/* If it fails, maybe we raced another insertion? */
 	if (sta_info_insert_rcu(sta))
 		return sta_info_get(sdata, addr);
+
+#ifdef FCI_SPA
+	sdata_info(sdata, "Added new IBSS neigboring station %pM\n", addr);
+	sta->sta.is_spa_beam = 0;
+	sta->spa_beacon_count = 0;	
+	spa_initialize_beam_signal_averages(sta);
+#endif /* FCI_SPA */
+
 	return sta;
 }
 
@@ -649,7 +686,7 @@ ieee80211_ibss_add_sta(struct ieee80211_
 		return NULL;
 	}
 
-	sta->last_rx = jiffies;
+	sta->last_rx = jiffies;   
 
 	/* make sure mandatory rates are always added */
 	sband = local->hw.wiphy->bands[band];
@@ -943,6 +980,42 @@ ieee80211_rx_mgmt_spectrum_mgmt(struct i
 		ieee80211_ibss_process_chanswitch(sdata, elems, false);
 }
 
+#ifdef FCI_SPA
+/*
+static u8 spa_max_beam_count(struct ieee80211_sub_if_data *sdata)
+{
+      u8 i, mapped_beam_id;
+      unsigned long max_count = 0;
+	struct ieee80211_local *local = sdata->local;
+	      
+      for (i=0; i <= SPA_MAX_BEAMS; i++) { 
+            if (local->spa_beam_count[i] > max_count) {
+                  max_count = local->spa_beam_count[i];
+                  mapped_beam_id = i;
+            }
+      }
+      return mapped_beam_id;
+}
+*/
+static void spa_rx_mgmt_beam_update(struct ieee80211_sub_if_data *sdata,
+				struct ieee80211_mgmt *mgmt)
+{
+	int required_len;
+	struct sta_info *sta;
+	
+	rcu_read_lock();	
+	sta = sta_info_get(sdata, mgmt->sa);	
+	/*if (sta && mgmt->u.action.u.spa_beam_feedback.beam_id != 0)*/
+	{
+	      sta->sta.is_spa_beam = mgmt->u.action.u.spa_beam_feedback.beam_id;
+	      printk(KERN_INFO "%s: Feedback update has happened, %pM now mapped to beam_ID= %d\n",
+	                   __func__, mgmt->sa,
+	                              mgmt->u.action.u.spa_beam_feedback.beam_id);
+	}     
+	rcu_read_unlock();		      
+}
+ #endif /* FCI_SPA */
+
 static void ieee80211_rx_mgmt_deauth_ibss(struct ieee80211_sub_if_data *sdata,
 					  struct ieee80211_mgmt *mgmt,
 					  size_t len)
@@ -1467,6 +1540,95 @@ static void ieee80211_rx_mgmt_probe_req(
 	ieee80211_tx_skb(sdata, skb);
 }
 
+#ifdef FCI_SPA
+static int
+spa_send_updated_beam(struct ieee80211_sub_if_data *sdata, const u8 *da,
+			                  u8 beam_id)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct sk_buff *skb;
+	struct ieee80211_mgmt *action_frame;
+	
+	int hdr_len =offsetof(struct ieee80211_mgmt, u.action.u.spa_beam_feedback)
+		      + sizeof(action_frame->u.action.u.spa_beam_feedback);
+		      
+	// 27 = header + category + action + spa_beam 
+	skb = dev_alloc_skb(2 + local->tx_headroom + hdr_len);
+	if (!skb)
+		return -ENOMEM;
+
+	skb_reserve(skb, local->tx_headroom);
+	action_frame = (struct ieee80211_mgmt *) skb_put(skb, hdr_len);
+	memset(action_frame,0,hdr_len);
+	action_frame->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+						  IEEE80211_STYPE_ACTION);	
+	memcpy(action_frame->da, da, ETH_ALEN);
+	memcpy(action_frame->sa, sdata->vif.addr, ETH_ALEN);
+	memcpy(action_frame->bssid, sdata->u.ibss.bssid, ETH_ALEN);
+
+	action_frame->u.action.category = WLAN_CATEGORY_SPA_BEAM_FEEDBACK ;
+	action_frame->u.action.u.spa_beam_feedback.action = 1;
+	action_frame->u.action.u.spa_beam_feedback.beam_id = beam_id;
+	    
+	// we'll do more on status of this frame
+	IEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_CTL_REQ_TX_STATUS;
+	//IEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;
+	//IEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_CTL_NO_ACK;
+	ieee80211_tx_skb(sdata, skb);
+
+	return 0;
+}
+
+static u8 spa_find_max_signal(struct sta_info *sta)
+{
+      s8 max_signal = -110;
+      u8 i;
+      u8 spa_beam_new =0;
+      
+      //max_signal = (s8) -ewma_read(&sta->spa_beam_beacon_signals[0]);
+      for (i = 0; i < SPA_MAX_BEAMS; i++) {
+
+          if (((s8) -ewma_read(&sta->spa_beam_beacon_signals[i])) > max_signal){
+                max_signal = (s8) -ewma_read(&sta->spa_beam_beacon_signals[i]);
+                spa_beam_new = i;                 
+          }
+      }
+      /*printk(KERN_INFO "%s: Maximum signal reported to be = %d for beam_ID = %d of %pM\n",
+                                    __func__, max_signal, spa_beam_new,sta->sta.addr);*/
+      return spa_beam_new;
+}
+
+static void spa_update_beam(struct ieee80211_sub_if_data *sdata,
+				      struct ieee80211_mgmt *mgmt,
+				            u8 beam_id, int last_signal) 
+{
+      u8 spa_beam_new;
+      struct ieee80211_local *local = sdata->local;
+      struct sta_info *sta;
+      
+      rcu_read_lock();
+      /**/
+      sta = sta_info_get(sdata, mgmt->sa);
+	if(sta){
+	      ewma_add(&sta->spa_beam_beacon_signals[beam_id], -last_signal);
+            sta->spa_beacon_count++;
+            /*if (sta->spa_beacon_count == local->spa_beam_feedback_interval[0] 
+              ||  sta->spa_beacon_count == local->spa_beam_feedback_interval[1] 
+              || sta->spa_beacon_count == local->spa_beam_feedback_interval[2] 
+              ||  sta->spa_beacon_count == local->spa_beam_feedback_interval[3] 
+              || sta->spa_beacon_count == local->spa_beam_feedback_interval[4]){*/
+            if(sta->spa_beacon_count == 50){
+                      spa_beam_new = spa_find_max_signal(sta);
+                      spa_send_updated_beam(sdata, sta->sta.addr, spa_beam_new);
+            }
+            //if (sta->spa_beacon_count > local->spa_beam_feedback_interval[4]) 
+            if (sta->spa_beacon_count > 50) 
+                  sta->spa_beacon_count = 0; // Reset the counter
+     }
+     rcu_read_unlock();
+}
+#endif /* FCI_SPA */
+
 static
 void ieee80211_rx_mgmt_probe_beacon(struct ieee80211_sub_if_data *sdata,
 				    struct ieee80211_mgmt *mgmt, size_t len,
@@ -1474,6 +1636,9 @@ void ieee80211_rx_mgmt_probe_beacon(stru
 {
 	size_t baselen;
 	struct ieee802_11_elems elems;
+#ifdef FCI_SPA	
+	struct sta_info *sta;
+#endif /* FCI_SPA */
 
 	BUILD_BUG_ON(offsetof(typeof(mgmt->u.probe_resp), variable) !=
 		     offsetof(typeof(mgmt->u.beacon), variable));
@@ -1490,6 +1655,17 @@ void ieee80211_rx_mgmt_probe_beacon(stru
 			       false, &elems);
 
 	ieee80211_rx_bss_info(sdata, mgmt, len, rx_status, &elems);
+	
+#ifdef FCI_SPA
+	/*mutex_lock(&sdata->local->sta_mtx);
+	sta = sta_info_get(sdata, mgmt->bssid);
+      if (sta && elems.ie_beam) {
+            mutex_unlock(&sdata->local->sta_mtx);                       
+            spa_update_beam(sdata, mgmt, elems.ie_beam, rx_status->signal);
+      }
+      mutex_unlock(&sdata->local->sta_mtx);  */
+      spa_update_beam(sdata, mgmt, elems.ie_beam, rx_status->signal);                     
+#endif /* FCI_SPA */	
 }
 
 void ieee80211_ibss_rx_queued_mgmt(struct ieee80211_sub_if_data *sdata,
@@ -1526,6 +1702,7 @@ void ieee80211_ibss_rx_queued_mgmt(struc
 		ieee80211_rx_mgmt_deauth_ibss(sdata, mgmt, skb->len);
 		break;
 	case IEEE80211_STYPE_ACTION:
+
 		switch (mgmt->u.action.category) {
 		case WLAN_CATEGORY_SPECTRUM_MGMT:
 			ies_len = skb->len -
@@ -1545,6 +1722,18 @@ void ieee80211_ibss_rx_queued_mgmt(struc
 			ieee80211_rx_mgmt_spectrum_mgmt(sdata, mgmt, skb->len,
 							rx_status, &elems);
 			break;
+#ifdef FCI_SPA
+            case WLAN_CATEGORY_SPA_BEAM_FEEDBACK:
+			ies_len = skb->len -
+				  offsetof(struct ieee80211_mgmt,
+					   u.action.u.spa_beam_feedback.beam_id);
+
+			if (ies_len < 0)
+				break;
+				
+			spa_rx_mgmt_beam_update(sdata, mgmt);
+			break;
+#endif /* FCI_SPA*/
 		}
 	}
 
diff -Npurd /home/user/download/compat-wireless-2014-05-22/net/mac80211/ieee80211_i.h /home/user/modified/compat-wireless-2014-05-22/net/mac80211/ieee80211_i.h
--- /home/user/download/compat-wireless-2014-05-22/net/mac80211/ieee80211_i.h	2014-11-30 08:56:34.423284759 +0200
+++ /home/user/modified/compat-wireless-2014-05-22/net/mac80211/ieee80211_i.h	2015-03-09 13:43:00.995084136 +0200
@@ -4,6 +4,8 @@
  * Copyright 2006-2007	Jiri Benc <jbenc@suse.cz>
  * Copyright 2007-2010	Johannes Berg <johannes@sipsolutions.net>
  *
+ * Modified by Mofolo Mofolo <mmofolo@csir.co.za>, December 2014
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
@@ -1274,6 +1276,11 @@ struct ieee80211_local {
 	/* virtual monitor interface */
 	struct ieee80211_sub_if_data __rcu *monitor_sdata;
 	struct cfg80211_chan_def monitor_chandef;
+
+#ifdef FCI_SPA
+      unsigned long spa_beam_feedback_interval[SPA_MAX_BEAMS];
+      unsigned long spa_beam_count[SPA_MAX_BEAMS];	
+#endif /* FCI_SPA*/      
 };
 
 static inline struct ieee80211_sub_if_data *
@@ -1341,6 +1348,10 @@ struct ieee802_11_elems {
 	const struct ieee80211_sec_chan_offs_ie *sec_chan_offs;
 	const struct ieee80211_mesh_chansw_params_ie *mesh_chansw_params_ie;
 
+#ifdef FCI_SPA
+      u8 ie_beam;
+#endif /* FCI_SPA */      
+
 	/* length of them, respectively */
 	u8 ssid_len;
 	u8 supp_rates_len;
diff -Npurd /home/user/download/compat-wireless-2014-05-22/net/mac80211/Makefile /home/user/modified/compat-wireless-2014-05-22/net/mac80211/Makefile
--- /home/user/download/compat-wireless-2014-05-22/net/mac80211/Makefile	2014-11-30 08:56:33.987284748 +0200
+++ /home/user/modified/compat-wireless-2014-05-22/net/mac80211/Makefile	2014-12-22 13:13:08.749814441 +0200
@@ -62,4 +62,4 @@ mac80211-$(CPTCFG_MAC80211_RC_PID) += $(
 mac80211-$(CPTCFG_MAC80211_RC_MINSTREL) += $(rc80211_minstrel-y)
 mac80211-$(CPTCFG_MAC80211_RC_MINSTREL_HT) += $(rc80211_minstrel_ht-y)
 
-ccflags-y += -D__CHECK_ENDIAN__ -DDEBUG
+ccflags-y += -D__CHECK_ENDIAN__ -DDEBUG -DFCI_SPA
diff -Npurd /home/user/download/compat-wireless-2014-05-22/net/mac80211/mlme.c /home/user/modified/compat-wireless-2014-05-22/net/mac80211/mlme.c
--- /home/user/download/compat-wireless-2014-05-22/net/mac80211/mlme.c	2014-05-23 19:32:18.000000000 +0200
+++ /home/user/modified/compat-wireless-2014-05-22/net/mac80211/mlme.c	2015-03-09 14:08:15.107122905 +0200
@@ -5,6 +5,8 @@
  * Copyright 2005, Devicescape Software, Inc.
  * Copyright 2006-2007	Jiri Benc <jbenc@suse.cz>
  * Copyright 2007, Michael Wu <flamingice@sourmilk.net>
+ * 
+ * Modified by Mofolo Mofolo <mmofolo@csir.co.za>, December 2014
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -2822,6 +2824,91 @@ static void ieee80211_rx_bss_info(struct
 	}
 }
 
+#ifdef FCI_SPA
+static int
+spa_send_updated_beam(struct ieee80211_sub_if_data *sdata, const u8 *da,
+			                  u8 beam_id)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct sk_buff *skb;
+	struct ieee80211_mgmt *action_frame;
+	
+	int hdr_len =offsetof(struct ieee80211_mgmt, u.action.u.spa_beam_feedback)
+		      + sizeof(action_frame->u.action.u.spa_beam_feedback);
+		      
+	// 27 = header + category + action + spa_beam 
+	skb = dev_alloc_skb(2 + local->tx_headroom + hdr_len);
+	if (!skb)
+		return -ENOMEM;
+
+	skb_reserve(skb, local->tx_headroom);
+	action_frame = (struct ieee80211_mgmt *) skb_put(skb, hdr_len);
+	memset(action_frame,0,hdr_len);
+	action_frame->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+						  IEEE80211_STYPE_ACTION);	
+	memcpy(action_frame->da, da, ETH_ALEN);
+	memcpy(action_frame->sa, sdata->vif.addr, ETH_ALEN);
+	memcpy(action_frame->bssid, sdata->u.ibss.bssid, ETH_ALEN);
+
+	action_frame->u.action.category = WLAN_CATEGORY_SPA_BEAM_FEEDBACK ;
+	action_frame->u.action.u.spa_beam_feedback.action = 1;
+	action_frame->u.action.u.spa_beam_feedback.beam_id = beam_id;
+	     
+	// we'll do more on status of this frame
+	//IEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_CTL_REQ_TX_STATUS;
+	IEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;
+	IEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_CTL_NO_ACK;
+	ieee80211_tx_skb(sdata, skb);
+
+	return 0;
+}
+
+static u8 spa_find_max_signal(struct sta_info *sta)
+{
+      int max_signal;
+      u8 i;
+      u8 spa_beam_new =0;
+      
+      max_signal = (s8) -ewma_read(&sta->spa_beam_beacon_signals[0]);
+      for (i = 1; i < SPA_MAX_BEAMS; i++) {
+
+          if (((s8) -ewma_read(&sta->spa_beam_beacon_signals[i])) > max_signal){
+                 max_signal = (s8) -ewma_read(&sta->spa_beam_beacon_signals[i]);
+                spa_beam_new = i;                 
+          }
+      }
+      return spa_beam_new;
+}
+
+static void spa_update_beam(struct ieee80211_sub_if_data *sdata,
+				      struct ieee80211_mgmt *mgmt,
+				            u8 beam_id, int last_signal) 
+{
+      u8 spa_beam_new;
+      struct ieee80211_local *local = sdata->local;
+      struct sta_info *sta;
+      
+      rcu_read_lock();
+      /**/
+      sta = sta_info_get(sdata, mgmt->sa);
+	if(sta){
+	      ewma_add(&sta->spa_beam_beacon_signals[beam_id], -last_signal);
+            sta->spa_beacon_count++;
+            if (sta->spa_beacon_count == local->spa_beam_feedback_interval[0] 
+              ||  sta->spa_beacon_count == local->spa_beam_feedback_interval[1] 
+              || sta->spa_beacon_count == local->spa_beam_feedback_interval[2] 
+              ||  sta->spa_beacon_count == local->spa_beam_feedback_interval[3] 
+              || sta->spa_beacon_count == local->spa_beam_feedback_interval[4]){
+                   
+                      spa_beam_new = spa_find_max_signal(sta);
+                      spa_send_updated_beam(sdata, sta->sta.addr, spa_beam_new);
+            }
+            if (sta->spa_beacon_count > local->spa_beam_feedback_interval[4]) 
+                  sta->spa_beacon_count = 0; // Reset the counter
+     }
+     rcu_read_unlock();
+}
+#endif /* FCI_SPA */
 
 static void ieee80211_rx_mgmt_probe_resp(struct ieee80211_sub_if_data *sdata,
 					 struct sk_buff *skb)
@@ -3169,6 +3256,14 @@ static void ieee80211_rx_mgmt_beacon(str
 	if (sta && elems.opmode_notif)
 		ieee80211_vht_handle_opmode(sdata, sta, *elems.opmode_notif,
 					    rx_status->band, true);
+#ifdef FCI_SPA
+//    if (sta && elems.ie_beam){
+      if (sta){
+               printk(KERN_INFO "%s: About to call spa_update_beam for beam = %d\n", __func__, (elems.ie_beam));
+               spa_update_beam(sdata, mgmt, elems.ie_beam, rx_status->signal);
+      }	
+#endif /* FCI_SPA */	
+
 	mutex_unlock(&local->sta_mtx);
 
 	if (elems.country_elem && elems.pwr_constr_elem &&
diff -Npurd /home/user/download/compat-wireless-2014-05-22/net/mac80211/rx.c /home/user/modified/compat-wireless-2014-05-22/net/mac80211/rx.c
--- /home/user/download/compat-wireless-2014-05-22/net/mac80211/rx.c	2014-11-30 08:56:33.975284747 +0200
+++ /home/user/modified/compat-wireless-2014-05-22/net/mac80211/rx.c	2015-03-09 14:07:10.855121260 +0200
@@ -4,6 +4,8 @@
  * Copyright 2006-2007	Jiri Benc <jbenc@suse.cz>
  * Copyright 2007-2010	Johannes Berg <johannes@sipsolutions.net>
  *
+ * Modified by Mofolo Mofolo <mmofolo@csir.co.za>, December 2014
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
@@ -2661,6 +2663,13 @@ ieee80211_rx_h_action(struct ieee80211_r
 		    !mesh_path_sel_is_hwmp(sdata))
 			break;
 		goto queue;
+
+#ifdef FCI_SPA
+	case WLAN_CATEGORY_SPA_BEAM_FEEDBACK:
+		if (len < (IEEE80211_MIN_ACTION_SIZE + 2 ))
+		      goto invalid;            
+		goto queue;
+#endif /* FCI_SPA */
 	}
 
 	return RX_CONTINUE;
diff -Npurd /home/user/download/compat-wireless-2014-05-22/net/mac80211/sta_info.c /home/user/modified/compat-wireless-2014-05-22/net/mac80211/sta_info.c
--- /home/user/download/compat-wireless-2014-05-22/net/mac80211/sta_info.c	2014-12-01 18:04:23.779016417 +0200
+++ /home/user/modified/compat-wireless-2014-05-22/net/mac80211/sta_info.c	2014-12-22 14:14:32.993908776 +0200
@@ -2,6 +2,8 @@
  * Copyright 2002-2005, Instant802 Networks, Inc.
  * Copyright 2006-2007	Jiri Benc <jbenc@suse.cz>
  *
+ * Modified by Mofolo Mofolo <mmofolo@csir.co.za>, December 2014
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
@@ -405,6 +407,11 @@ struct sta_info *sta_info_alloc(struct i
 		}
 	}
 
+#ifdef FCI_SPA
+      for (i = 0; i < SPA_MAX_BEAMS; i++)
+		ewma_init(&sta->spa_beam_beacon_signals[i], 1024, 8);
+#endif /* FCI_SPA*/
+
 	sta_dbg(sdata, "Allocated STA %pM\n", sta->sta.addr);
 	return sta;
 
@@ -1051,7 +1058,7 @@ struct ieee80211_sta *ieee80211_find_sta
 					       const u8 *localaddr)
 {
 	struct sta_info *sta, *nxt;
-
+	
 	/*
 	 * Just return a random station if localaddr is NULL
 	 * ... first in list.
@@ -1755,7 +1762,12 @@ void sta_set_sinfo(struct sta_info *sta,
 			STATION_INFO_BSS_PARAM |
 			STATION_INFO_CONNECTED_TIME |
 			STATION_INFO_STA_FLAGS |
+#ifdef FCI_SPA
+                        STATION_INFO_BEACON_LOSS_COUNT |
+                        STATION_INFO_SPA_BEAM;
+#else
 			STATION_INFO_BEACON_LOSS_COUNT;
+#endif /* FCI_SPA */                       			
 
 	do_posix_clock_monotonic_gettime(&uptime);
 	sinfo->connected_time = uptime.tv_sec - sta->last_connected;
@@ -1837,6 +1849,7 @@ void sta_set_sinfo(struct sta_info *sta,
 				BIT(NL80211_STA_FLAG_AUTHENTICATED) |
 				BIT(NL80211_STA_FLAG_ASSOCIATED) |
 				BIT(NL80211_STA_FLAG_TDLS_PEER);
+								
 	if (test_sta_flag(sta, WLAN_STA_AUTHORIZED))
 		sinfo->sta_flags.set |= BIT(NL80211_STA_FLAG_AUTHORIZED);
 	if (test_sta_flag(sta, WLAN_STA_SHORT_PREAMBLE))
@@ -1852,6 +1865,11 @@ void sta_set_sinfo(struct sta_info *sta,
 	if (test_sta_flag(sta, WLAN_STA_TDLS_PEER))
 		sinfo->sta_flags.set |= BIT(NL80211_STA_FLAG_TDLS_PEER);
 
+#ifdef FCI_SPA
+        sinfo->spa_beam = sta->sta.is_spa_beam;
+        sinfo->sta_flags.set |= BIT(NL80211_STA_INFO_BEAM);
+#endif /* FCI_SPA */
+
 	/* check if the driver has a SW RC implementation */
 	if (ref && ref->ops->get_expected_throughput)
 		thr = ref->ops->get_expected_throughput(sta->rate_ctrl_priv);
diff -Npurd /home/user/download/compat-wireless-2014-05-22/net/mac80211/sta_info.h /home/user/modified/compat-wireless-2014-05-22/net/mac80211/sta_info.h
--- /home/user/download/compat-wireless-2014-05-22/net/mac80211/sta_info.h	2014-11-30 08:56:33.979284747 +0200
+++ /home/user/modified/compat-wireless-2014-05-22/net/mac80211/sta_info.h	2014-12-22 15:50:21.658055971 +0200
@@ -1,6 +1,8 @@
 /*
  * Copyright 2002-2005, Devicescape Software, Inc.
  *
+ * Modified by Mofolo Mofolo <mmofolo@csir.co.za>, December 2014
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
@@ -17,6 +19,12 @@
 #include <linux/etherdevice.h>
 #include "key.h"
 
+#ifdef FCI_SPA
+      #ifndef SPA_MAX_BEAMS
+            #define SPA_MAX_BEAMS 5
+      #endif
+#endif /* FCI_SPA*/
+
 /**
  * enum ieee80211_sta_info_flags - Stations flags
  *
@@ -444,6 +452,13 @@ struct sta_info {
 	enum ieee80211_smps_mode known_smps_mode;
 	const struct ieee80211_cipher_scheme *cipher_scheme;
 
+#ifdef FCI_SPA
+      int spa_beacon_rssi;
+      unsigned long spa_beacon_count;
+      struct ewma spa_beam_beacon_signals[SPA_MAX_BEAMS];
+      int spa_max_beacon_signal;
+#endif /* FCI_SPA */
+
 	/* keep last! */
 	struct ieee80211_sta sta;
 };
diff -Npurd /home/user/download/compat-wireless-2014-05-22/net/mac80211/tx.c /home/user/modified/compat-wireless-2014-05-22/net/mac80211/tx.c
--- /home/user/download/compat-wireless-2014-05-22/net/mac80211/tx.c	2014-11-30 08:56:33.979284747 +0200
+++ /home/user/modified/compat-wireless-2014-05-22/net/mac80211/tx.c	2015-02-25 13:15:06.430493140 +0200
@@ -4,6 +4,8 @@
  * Copyright 2006-2007	Jiri Benc <jbenc@suse.cz>
  * Copyright 2007	Johannes Berg <johannes@sipsolutions.net>
  *
+ * Modified by Mofolo Mofolo <mmofolo@csir.co.za>, December 2014
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
@@ -2771,6 +2773,236 @@ struct sk_buff *ieee80211_beacon_get_tim
 }
 EXPORT_SYMBOL(ieee80211_beacon_get_tim);
 
+#ifdef FCI_SPA
+static void __spa_beacon_add_beam(struct ieee80211_sub_if_data *sdata, 
+                                        struct sk_buff *skb, u8 beam_id)
+{
+      u8 *pos;
+      pos = (u8 *) skb_put(skb, 3);
+	*pos++ = WLAN_EID_ANTENNA_SECTOR_ID_PATTERN;
+	*pos++ = 1;
+	*pos++ = beam_id;
+}
+
+static struct sk_buff *
+__spa_beacon_get(struct ieee80211_hw *hw,
+		       struct ieee80211_vif *vif,
+		       struct ieee80211_mutable_offsets *offs,
+		       bool is_template,
+		       u8 beam_id)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+	struct beacon_data *beacon = NULL;
+	struct sk_buff *skb = NULL;
+	struct ieee80211_tx_info *info;
+	struct ieee80211_sub_if_data *sdata = NULL;
+	enum ieee80211_band band;
+	struct ieee80211_tx_rate_control txrc;
+	struct ieee80211_chanctx_conf *chanctx_conf;
+	int csa_off_base = 0;
+
+	rcu_read_lock();
+
+	sdata = vif_to_sdata(vif);
+	chanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);
+
+	if (!ieee80211_sdata_running(sdata) || !chanctx_conf)
+		goto out;
+
+	if (offs)
+		memset(offs, 0, sizeof(*offs));
+
+	if (sdata->vif.type == NL80211_IFTYPE_AP) {
+		struct ieee80211_if_ap *ap = &sdata->u.ap;
+
+		beacon = rcu_dereference(ap->beacon);
+		if (beacon) {
+			if (beacon->csa_counter_offsets[0]) {
+				if (!is_template)
+					ieee80211_csa_update_counter(vif);
+
+				ieee80211_set_csa(sdata, beacon);
+			}
+
+			/*
+			 * headroom, head length,
+			 * tail length and maximum TIM length
+			 */
+			skb = dev_alloc_skb(local->tx_headroom +
+					    beacon->head_len +
+					    beacon->tail_len + 256 +
+					    local->hw.extra_beacon_tailroom);
+			if (!skb)
+				goto out;
+
+			skb_reserve(skb, local->tx_headroom);
+			memcpy(skb_put(skb, beacon->head_len), beacon->head,
+			       beacon->head_len);
+
+			ieee80211_beacon_add_tim(sdata, &ap->ps, skb,
+						 is_template);
+
+			if (offs) {
+				offs->tim_offset = beacon->head_len;
+				offs->tim_length = skb->len - beacon->head_len;
+
+				/* for AP the csa offsets are from tail */
+				csa_off_base = skb->len;
+			}
+
+			if (beacon->tail)
+				memcpy(skb_put(skb, beacon->tail_len),
+				       beacon->tail, beacon->tail_len);
+		} else
+			goto out;
+	} else if (sdata->vif.type == NL80211_IFTYPE_ADHOC) {
+		struct ieee80211_if_ibss *ifibss = &sdata->u.ibss;
+		struct ieee80211_hdr *hdr;
+
+		beacon = rcu_dereference(ifibss->presp);
+		if (!beacon)
+			goto out;
+
+		if (beacon->csa_counter_offsets[0]) {
+			if (!is_template)
+				ieee80211_csa_update_counter(vif);
+
+			ieee80211_set_csa(sdata, beacon);
+		}
+
+		skb = dev_alloc_skb(local->tx_headroom + beacon->head_len +
+				    3 + /* antenna sector_ID IE length */
+				    local->hw.extra_beacon_tailroom);
+		if (!skb)
+			goto out;
+			
+		skb_reserve(skb, local->tx_headroom);
+		memcpy(skb_put(skb, beacon->head_len), beacon->head,
+		       beacon->head_len);
+		
+		spin_lock_bh(&local->tim_lock);
+		__spa_beacon_add_beam(sdata, skb, beam_id);
+		spin_unlock_bh(&local->tim_lock);
+		
+		if (beacon->tail)
+			memcpy(skb_put(skb, beacon->tail_len),
+			       beacon->tail, beacon->tail_len);      
+
+		hdr = (struct ieee80211_hdr *) skb->data;
+		hdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+						 IEEE80211_STYPE_BEACON);
+	} else if (ieee80211_vif_is_mesh(&sdata->vif)) {
+		struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
+
+		beacon = rcu_dereference(ifmsh->beacon);
+		if (!beacon)
+			goto out;
+
+		if (beacon->csa_counter_offsets[0]) {
+			if (!is_template)
+				/* TODO: For mesh csa_counter is in TU, so
+				 * decrementing it by one isn't correct, but
+				 * for now we leave it consistent with overall
+				 * mac80211's behavior.
+				 */
+				ieee80211_csa_update_counter(vif);
+
+			ieee80211_set_csa(sdata, beacon);
+		}
+
+		if (ifmsh->sync_ops)
+			ifmsh->sync_ops->adjust_tbtt(sdata, beacon);
+
+		skb = dev_alloc_skb(local->tx_headroom +
+				    beacon->head_len +
+				    256 + /* TIM IE */
+				    beacon->tail_len +
+				    local->hw.extra_beacon_tailroom);
+		if (!skb)
+			goto out;
+		skb_reserve(skb, local->tx_headroom);
+		memcpy(skb_put(skb, beacon->head_len), beacon->head,
+		       beacon->head_len);
+		ieee80211_beacon_add_tim(sdata, &ifmsh->ps, skb, is_template);
+
+		if (offs) {
+			offs->tim_offset = beacon->head_len;
+			offs->tim_length = skb->len - beacon->head_len;
+		}
+
+		memcpy(skb_put(skb, beacon->tail_len), beacon->tail,
+		       beacon->tail_len);
+	} else {
+		WARN_ON(1);
+		goto out;
+	}
+
+	/* CSA offsets */
+	if (offs && beacon) {
+		int i;
+
+		for (i = 0; i < IEEE80211_MAX_CSA_COUNTERS_NUM; i++) {
+			u16 csa_off = beacon->csa_counter_offsets[i];
+
+			if (!csa_off)
+				continue;
+
+			offs->csa_counter_offs[i] = csa_off_base + csa_off;
+		}
+	}
+
+	band = chanctx_conf->def.chan->band;
+
+	info = IEEE80211_SKB_CB(skb);
+
+	info->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;
+	info->flags |= IEEE80211_TX_CTL_NO_ACK;
+	info->band = band;
+
+	memset(&txrc, 0, sizeof(txrc));
+	txrc.hw = hw;
+	txrc.sband = local->hw.wiphy->bands[band];
+	txrc.bss_conf = &sdata->vif.bss_conf;
+	txrc.skb = skb;
+	txrc.reported_rate.idx = -1;
+	txrc.rate_idx_mask = sdata->rc_rateidx_mask[band];
+	if (txrc.rate_idx_mask == (1 << txrc.sband->n_bitrates) - 1)
+		txrc.max_rate_idx = -1;
+	else
+		txrc.max_rate_idx = fls(txrc.rate_idx_mask) - 1;
+	txrc.bss = true;
+	rate_control_get_rate(sdata, NULL, &txrc);
+
+	info->control.vif = vif;
+
+	info->flags |= IEEE80211_TX_CTL_CLEAR_PS_FILT |
+			IEEE80211_TX_CTL_ASSIGN_SEQ |
+			IEEE80211_TX_CTL_FIRST_FRAGMENT;
+ out:
+	rcu_read_unlock();
+	return skb;
+
+}
+
+struct sk_buff *spa_beacon_get_tim(struct ieee80211_hw *hw,
+					 struct ieee80211_vif *vif,
+					 u16 *tim_offset, u16 *tim_length,
+					 u8 beam_id)
+{
+	struct ieee80211_mutable_offsets offs = {};
+	struct sk_buff *bcn = __spa_beacon_get(hw, vif, &offs, false, beam_id);
+
+	if (tim_offset)
+		*tim_offset = offs.tim_offset;
+
+	if (tim_length)
+		*tim_length = offs.tim_length;
+
+	return bcn;
+}
+EXPORT_SYMBOL(spa_beacon_get_tim);
+#endif /* FCI_SPA */
+
 struct sk_buff *ieee80211_proberesp_get(struct ieee80211_hw *hw,
 					struct ieee80211_vif *vif)
 {
diff -Npurd /home/user/download/compat-wireless-2014-05-22/net/mac80211/util.c /home/user/modified/compat-wireless-2014-05-22/net/mac80211/util.c
--- /home/user/download/compat-wireless-2014-05-22/net/mac80211/util.c	2014-05-23 19:32:18.000000000 +0200
+++ /home/user/modified/compat-wireless-2014-05-22/net/mac80211/util.c	2015-03-09 14:10:25.711126249 +0200
@@ -4,6 +4,8 @@
  * Copyright 2006-2007	Jiri Benc <jbenc@suse.cz>
  * Copyright 2007	Johannes Berg <johannes@sipsolutions.net>
  *
+ * Modified by Mofolo Mofolo <mmofolo@csir.co.za>, December 2014
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
@@ -716,7 +718,7 @@ u32 ieee802_11_parse_elems_crc(const u8
 			elems->parse_error = true;
 			break;
 		}
-
+		
 		switch (id) {
 		case WLAN_EID_SSID:
 		case WLAN_EID_SUPP_RATES:
@@ -752,6 +754,10 @@ u32 ieee802_11_parse_elems_crc(const u8
 		 * not listing WLAN_EID_CHANNEL_SWITCH_WRAPPER -- it seems possible
 		 * that if the content gets bigger it might be needed more than once
 		 */
+#ifdef FCI_SPA
+		case WLAN_EID_ANTENNA_SECTOR_ID_PATTERN:
+#endif /* FCI_SPA */
+	
 			if (test_bit(id, seen_elems)) {
 				elems->parse_error = true;
 				left -= elen;
@@ -966,6 +972,15 @@ u32 ieee802_11_parse_elems_crc(const u8
 			else
 				elem_parse_failed = true;
 			break;
+#ifdef FCI_SPA
+		case WLAN_EID_ANTENNA_SECTOR_ID_PATTERN:
+		      if(elen != 1) {
+				elem_parse_failed = true;
+				break;		        
+		        }
+			elems->ie_beam = (u8)pos[0];
+                  break;
+#endif /* FCI_SPA */			
 		default:
 			break;
 		}
diff -Npurd /home/user/download/compat-wireless-2014-05-22/net/wireless/Makefile /home/user/modified/compat-wireless-2014-05-22/net/wireless/Makefile
--- /home/user/download/compat-wireless-2014-05-22/net/wireless/Makefile	2014-05-23 19:32:18.000000000 +0200
+++ /home/user/modified/compat-wireless-2014-05-22/net/wireless/Makefile	2014-12-22 13:13:08.753814441 +0200
@@ -17,7 +17,8 @@ cfg80211-$(CPTCFG_CFG80211_INTERNAL_REGD
 
 CFLAGS_trace.o := -I$(src)
 
-ccflags-y += -D__CHECK_ENDIAN__
+ccflags-y += -D__CHECK_ENDIAN__ -DFCI_SPA
+
 
 $(obj)/regdb.c: $(src)/db.txt $(src)/genregdb.awk
 	@$(AWK) -f $(src)/genregdb.awk < $< > $@
diff -Npurd /home/user/download/compat-wireless-2014-05-22/net/wireless/nl80211.c /home/user/modified/compat-wireless-2014-05-22/net/wireless/nl80211.c
--- /home/user/download/compat-wireless-2014-05-22/net/wireless/nl80211.c	2014-11-30 08:56:34.427284759 +0200
+++ /home/user/modified/compat-wireless-2014-05-22/net/wireless/nl80211.c	2014-12-22 13:13:08.753814441 +0200
@@ -2,6 +2,8 @@
  * This is the new netlink-based wireless configuration interface.
  *
  * Copyright 2006-2010	Johannes Berg <johannes@sipsolutions.net>
+ *
+ * Modified by Mofolo Mofolo <mmofolo@csir.co.za>, December 2014
  */
 
 #include <linux/if.h>
@@ -11,7 +13,7 @@
 #include <linux/list.h>
 #include <linux/if_ether.h>
 #include <linux/ieee80211.h>
-#include <linux/nl80211.h>
+//#include <linux/nl80211.h>
 #include <linux/rtnetlink.h>
 #include <linux/netlink.h>
 #include <linux/etherdevice.h>
@@ -24,6 +26,7 @@
 #include "nl80211.h"
 #include "reg.h"
 #include "rdev-ops.h"
+#include <uapi/linux/nl80211.h>
 
 static int nl80211_crypto_settings(struct cfg80211_registered_device *rdev,
 				   struct genl_info *info,
@@ -388,6 +391,10 @@ static const struct nla_policy nl80211_p
 	[NL80211_ATTR_IFACE_SOCKET_OWNER] = { .type = NLA_FLAG },
 	[NL80211_ATTR_CSA_C_OFFSETS_TX] = { .type = NLA_BINARY },
 	[NL80211_ATTR_WIPHY_ANTENNA_GAIN] = { .type = NLA_U32 },
+#ifdef FCI_SPA
+	[NL80211_ATTR_SPA_BEAM_NUMBER] = { .type = NLA_U8 },
+	[NL80211_ATTR_SPA_NEXT_HOP] = { .len = ETH_ALEN },
+#endif  /* FCI_SPA */
 };
 
 /* policy for the key attributes */
@@ -3716,16 +3723,27 @@ static int nl80211_send_station(struct s
 		nla_put_u64(msg, NL80211_STA_INFO_T_OFFSET,
 			    sinfo->t_offset))
 		goto nla_put_failure;
+#ifdef FCI_SPA
+	if ((sinfo->filled & STATION_INFO_SPA_BEAM) &&
+	    nla_put_u8(msg, NL80211_STA_INFO_BEAM, sinfo->spa_beam)){
+	        printk(KERN_INFO "%s: was called at this point in time\n", __func__);
+		goto nla_put_failure;
+        }
+#endif /* FCI_SPA*/
+		
 	nla_nest_end(msg, sinfoattr);
 
 	if ((sinfo->filled & STATION_INFO_ASSOC_REQ_IES) &&
 	    nla_put(msg, NL80211_ATTR_IE, sinfo->assoc_req_ies_len,
 		    sinfo->assoc_req_ies))
 		goto nla_put_failure;
-
+	
 	return genlmsg_end(msg, hdr);
 
  nla_put_failure:
+#ifdef FCI_SPA
+        printk(KERN_INFO "%s: nla_put_failure exerienced at this point\n", __func__);
+#endif /* FCI_SPA*/        
 	genlmsg_cancel(msg, hdr);
 	return -EMSGSIZE;
 }
@@ -4551,6 +4569,32 @@ static int nl80211_set_mpath(struct sk_b
 	return rdev_change_mpath(rdev, dev, dst, next_hop);
 }
 
+#ifdef FCI_SPA
+static int nl80211_spa_beam_mapping(struct sk_buff *skb, struct genl_info *info)
+{
+    
+	struct cfg80211_registered_device *rdev = info->user_ptr[0];
+	struct net_device *dev = info->user_ptr[1];
+	u8 beam_number=0;
+	u8 *next_hop = NULL;
+
+	if (!info->attrs[NL80211_ATTR_SPA_BEAM_NUMBER])
+		return -EINVAL;
+
+	if (!info->attrs[NL80211_ATTR_SPA_NEXT_HOP])
+		return -EINVAL;
+
+	beam_number = nla_get_u8(info->attrs[NL80211_ATTR_SPA_BEAM_NUMBER]);
+	next_hop = nla_data(info->attrs[NL80211_ATTR_SPA_NEXT_HOP]);
+
+	if (!rdev->ops->spabeam)
+		return -EOPNOTSUPP;
+
+	return rdev_spabeam(rdev, dev, next_hop, beam_number);/**/
+}
+#endif /* FCI_SPA */
+
+
 static int nl80211_new_mpath(struct sk_buff *skb, struct genl_info *info)
 {
 	struct cfg80211_registered_device *rdev = info->user_ptr[0];
@@ -7947,6 +7991,8 @@ static int nl80211_set_power_save(struct
 	u8 ps_state;
 	bool state;
 	int err;
+	
+	printk(KERN_INFO "%s: was called at this point....\n", __func__);
 
 	if (!info->attrs[NL80211_ATTR_PS_STATE])
 		return -EINVAL;
@@ -10127,6 +10173,16 @@ static __genl_const struct genl_ops nl80
 		.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |
 				  NL80211_FLAG_NEED_RTNL,
 	},
+#ifdef FCI_SPA
+	{
+		.cmd = NL80211_CMD_MAP_SPA_BEAM,
+		.doit = nl80211_spa_beam_mapping,
+		.policy = nl80211_policy,
+		.flags = GENL_ADMIN_PERM,
+		.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |
+				  NL80211_FLAG_NEED_RTNL,
+	},
+#endif /* FCI_SPA */	
 };
 
 /* notification functions */
diff -Npurd /home/user/download/compat-wireless-2014-05-22/net/wireless/rdev-ops.h /home/user/modified/compat-wireless-2014-05-22/net/wireless/rdev-ops.h
--- /home/user/download/compat-wireless-2014-05-22/net/wireless/rdev-ops.h	2014-11-30 08:56:33.987284748 +0200
+++ /home/user/modified/compat-wireless-2014-05-22/net/wireless/rdev-ops.h	2014-12-22 13:13:08.753814441 +0200
@@ -915,4 +915,18 @@ rdev_set_ap_chanwidth(struct cfg80211_re
 	return ret;
 }
 
+#ifdef FCI_SPA
+static inline int rdev_spabeam(struct cfg80211_registered_device *rdev,
+				 struct net_device *dev, u8 *next_hop, u8 beam_number)
+{
+	int ret;
+        //printk(KERN_INFO "%s: was called at this point in time\n", __func__);
+	trace_rdev_spabeam(&rdev->wiphy, dev, next_hop, beam_number);
+	ret = rdev->ops->spabeam(&rdev->wiphy, dev, next_hop, beam_number);
+	trace_rdev_return_int(&rdev->wiphy, ret);
+
+	return ret;
+}
+#endif /* FCI_SPA */
+
 #endif /* __CFG80211_RDEV_OPS */
diff -Npurd /home/user/download/compat-wireless-2014-05-22/net/wireless/trace.h /home/user/modified/compat-wireless-2014-05-22/net/wireless/trace.h
--- /home/user/download/compat-wireless-2014-05-22/net/wireless/trace.h	2014-11-30 08:56:33.987284748 +0200
+++ /home/user/modified/compat-wireless-2014-05-22/net/wireless/trace.h	2014-12-22 13:13:08.753814441 +0200
@@ -2606,6 +2606,49 @@ TRACE_EVENT(cfg80211_stop_iface,
 		  WIPHY_PR_ARG, WDEV_PR_ARG)
 );
 
+#ifdef FCI_SPA
+/* Exported functions for tracing the beam configuration activities*/
+DECLARE_EVENT_CLASS(spabeam_evt,
+	TP_PROTO(struct wiphy *wiphy, struct net_device *netdev, u8 *next_hop,
+	         u8 beam_number),
+	TP_ARGS(wiphy, netdev, next_hop, beam_number),
+	TP_STRUCT__entry(
+		WIPHY_ENTRY
+		NETDEV_ENTRY
+		MAC_ENTRY(next_hop)
+		__field(u8, beam_number)
+	),
+	TP_fast_assign(
+		WIPHY_ASSIGN;
+		NETDEV_ASSIGN;
+		MAC_ASSIGN(next_hop, next_hop);
+		__entry->beam_number = beam_number;	
+	),
+	TP_printk(WIPHY_PR_FMT ", " NETDEV_PR_FMT ", next hop: " MAC_PR_FMT ", beam_number: %d",
+		  WIPHY_PR_ARG, NETDEV_PR_ARG, MAC_PR_ARG(next_hop), beam_number)
+);
+
+TRACE_EVENT(rdev_spabeam,
+	TP_PROTO(struct wiphy *wiphy, struct net_device *netdev, u8 *next_hop,
+	         u8 beam_number),
+	TP_ARGS(wiphy, netdev, next_hop, beam_number),
+	TP_STRUCT__entry(
+		WIPHY_ENTRY
+		NETDEV_ENTRY
+		MAC_ENTRY(next_hop)
+		__field(u8, beam_number)
+	),
+	TP_fast_assign(
+		WIPHY_ASSIGN;
+		NETDEV_ASSIGN;
+		MAC_ASSIGN(next_hop, next_hop);
+		__entry->beam_number = beam_number;	
+	),
+	TP_printk(WIPHY_PR_FMT ", " NETDEV_PR_FMT ", next hop: " MAC_PR_FMT ", beam_number: %d",
+		  WIPHY_PR_ARG, NETDEV_PR_ARG, MAC_PR_ARG(next_hop), __entry->beam_number)
+);
+#endif /* FCI_SPA */
+
 #endif /* !__RDEV_OPS_TRACE || TRACE_HEADER_MULTI_READ */
 
 #undef TRACE_INCLUDE_PATH
diff -Npurd /home/user/download/compat-wireless-2014-05-22/spa/spa.h /home/user/modified/compat-wireless-2014-05-22/spa/spa.h
--- /home/user/download/compat-wireless-2014-05-22/spa/spa.h	1970-01-01 02:00:00.000000000 +0200
+++ /home/user/modified/compat-wireless-2014-05-22/spa/spa.h	2014-12-22 13:13:08.753814441 +0200
@@ -0,0 +1,82 @@
+#ifndef _SPA_H
+#define _SPA_H
+
+#include <linux/gpio.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <asm/mach-ath79/ath79.h>
+
+static DEFINE_SPINLOCK(ath79_gpio_lock);
+enum beam_number {
+        beam_omni=0,
+        beam_1,
+        beam_2,
+        beam_3,
+        beam_4
+};
+
+static inline void spa_write_io(int bit_io_20,int bit_io_21,int bit_io_22,int bit_io_23)
+{
+        gpio_set_value(20,bit_io_20);
+        gpio_set_value(21,bit_io_21);
+        gpio_set_value(22,bit_io_22);
+        gpio_set_value(23,bit_io_23);
+}
+
+static inline void spa_gpio(u8 beam_number)
+{
+        switch (beam_number)
+        {
+           case beam_1:
+                 spa_write_io(0,0,1,1);
+                 break;
+           case beam_2:
+                 spa_write_io(1,0,0,1);
+                 break;
+           case beam_3:
+                 spa_write_io(1,1,0,0);
+                 break;
+           case beam_4:
+                 spa_write_io(0,1,1,0);
+                 break;
+           case beam_omni:
+           default:
+                 spa_write_io(0,0,0,0);
+                 break; 
+        }
+}
+
+static inline int setup_gpio (unsigned offset){
+
+	void __iomem *base = ath79_gpio_base;
+	unsigned long flags;
+	u32 out;
+	
+	spin_lock_irqsave(&ath79_gpio_lock, flags);
+	out = __raw_readl(base + AR71XX_GPIO_REG_OE);
+        //printk(KERN_INFO "Current GPIO_OE Value, %d\n",out);
+	/* __raw_writel( | (1 << offset),
+		     base + AR71XX_GPIO_REG_OE);*/
+        __raw_writel( out| (1 << offset),
+		     base + AR71XX_GPIO_REG_OE);
+
+	spin_unlock_irqrestore(&ath79_gpio_lock, flags);
+
+	return 0;
+}
+
+static inline void spa_setup_io(void)
+{ 
+        int gpio_err;
+        gpio_err = setup_gpio (20);
+	gpio_err = setup_gpio (21);
+	gpio_err = setup_gpio (22);
+	gpio_err = setup_gpio (23);
+	               
+	if (!gpio_err) {
+		gpio_set_value(20,1);
+		gpio_set_value(21,1);
+		gpio_set_value(22,1);
+		gpio_set_value(23,1);
+	}
+}
+#endif //spa.h
